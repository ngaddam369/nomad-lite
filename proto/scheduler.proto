syntax = "proto3";

package scheduler;

// ==================== Raft RPCs ====================

service RaftService {
    // Request vote from peer during election
    rpc RequestVote(VoteRequest) returns (VoteResponse);

    // Append entries (log replication) or heartbeat
    rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse);

    // Tell a follower to immediately start an election (leadership transfer)
    rpc TimeoutNow(TimeoutNowRequest) returns (TimeoutNowResponse);

    // Install a snapshot on a follower that is too far behind
    rpc InstallSnapshot(InstallSnapshotRequest) returns (InstallSnapshotResponse);
}

message VoteRequest {
    uint64 term = 1;
    uint64 candidate_id = 2;
    uint64 last_log_index = 3;
    uint64 last_log_term = 4;
}

message VoteResponse {
    uint64 term = 1;
    bool vote_granted = 2;
}

message AppendEntriesRequest {
    uint64 term = 1;
    uint64 leader_id = 2;
    uint64 prev_log_index = 3;
    uint64 prev_log_term = 4;
    repeated LogEntry entries = 5;
    uint64 leader_commit = 6;
}

message AppendEntriesResponse {
    uint64 term = 1;
    bool success = 2;
    // For optimization: the follower's last log index (helps leader update next_index faster)
    uint64 match_index = 3;
}

message TimeoutNowRequest {
    uint64 term = 1;
    uint64 leader_id = 2;
}

message TimeoutNowResponse {
    uint64 term = 1;
    bool success = 2;
}

message LogEntry {
    uint64 term = 1;
    uint64 index = 2;
    Command command = 3;
}

message InstallSnapshotRequest {
    uint64 term = 1;
    uint64 leader_id = 2;
    uint64 last_included_index = 3;
    uint64 last_included_term = 4;
    repeated SnapshotJob jobs = 5;
    repeated uint64 workers = 6;
}

message SnapshotJob {
    string job_id = 1;
    string command = 2;
    JobStatus status = 3;
    uint64 assigned_worker = 4;
    uint64 executed_by = 5;
    optional int32 exit_code = 6;
    int64 created_at_ms = 7;
    optional int64 completed_at_ms = 8;
}

message InstallSnapshotResponse {
    uint64 term = 1;
}

message Command {
    oneof command_type {
        SubmitJobCommand submit_job = 1;
        UpdateJobStatusCommand update_job_status = 2;
        RegisterWorkerCommand register_worker = 3;
        BatchUpdateJobStatusCommand batch_update_job_status = 4;
        AssignJobCommand assign_job = 5;
    }
}

message AssignJobCommand {
    string job_id    = 1;
    uint64 worker_id = 2;
}

message SubmitJobCommand {
    string job_id = 1;
    string command = 2;
    int64 created_at_ms = 3;
}

message UpdateJobStatusCommand {
    string job_id = 1;
    JobStatus status = 2;
    uint64 executed_by = 3;
    optional int32 exit_code = 4;
    optional int64 completed_at_ms = 5;
}

message RegisterWorkerCommand {
    uint64 worker_id = 1;
}

message JobStatusUpdate {
    string job_id = 1;
    JobStatus status = 2;
    uint64 executed_by = 3;
    optional int32 exit_code = 4;
    optional int64 completed_at_ms = 5;
}

message BatchUpdateJobStatusCommand {
    repeated JobStatusUpdate updates = 1;
}

// ==================== Client API ====================

service SchedulerService {
    // Submit a new job to the cluster
    rpc SubmitJob(SubmitJobRequest) returns (SubmitJobResponse);

    // Get status of a job
    rpc GetJobStatus(GetJobStatusRequest) returns (GetJobStatusResponse);

    // List all jobs (paginated, returns all at once)
    rpc ListJobs(ListJobsRequest) returns (ListJobsResponse);

    // Stream all jobs (memory-efficient for large job lists)
    rpc StreamJobs(StreamJobsRequest) returns (stream JobInfo);

    // Get cluster status (leader, nodes, etc.)
    rpc GetClusterStatus(GetClusterStatusRequest) returns (GetClusterStatusResponse);

    // Get Raft log entries
    rpc GetRaftLogEntries(GetRaftLogEntriesRequest) returns (GetRaftLogEntriesResponse);

    // Transfer leadership to another node (or auto-select)
    rpc TransferLeadership(TransferLeadershipRequest) returns (TransferLeadershipResponse);

    // Drain this node: stop accepting jobs, wait for running jobs to finish, transfer leadership
    rpc DrainNode(DrainNodeRequest) returns (DrainNodeResponse);
}

message SubmitJobRequest {
    string command = 1;
}

message SubmitJobResponse {
    // Job ID assigned to the submitted job
    string job_id = 1;
    // Timestamp when the job was created (milliseconds since epoch)
    int64 created_at_ms = 2;
}

message GetJobStatusRequest {
    string job_id = 1;
}

message GetJobStatusResponse {
    string job_id = 1;
    JobStatus status = 2;
    string output = 3;
    string error = 4;
    uint64 assigned_worker = 5;
    uint64 executed_by = 6;
    optional int32 exit_code = 7;
    // Timestamp when the job was created (milliseconds since epoch)
    int64 created_at_ms = 8;
    // Timestamp when the job completed (milliseconds since epoch), 0 if not completed
    optional int64 completed_at_ms = 9;
}

message ListJobsRequest {
    // Maximum number of jobs to return (default: 100, max: 1000)
    uint32 page_size = 1;
    // Page token from previous response for pagination
    string page_token = 2;
}

message StreamJobsRequest {
    // Optional filter by status (if unspecified, returns all jobs)
    JobStatus status_filter = 1;
}

message ListJobsResponse {
    repeated JobInfo jobs = 1;
    // Token to retrieve the next page of results (empty if no more pages)
    string next_page_token = 2;
    // Total number of jobs in the queue
    uint32 total_count = 3;
}

message JobInfo {
    string job_id = 1;
    string command = 2;
    JobStatus status = 3;
    uint64 assigned_worker = 4;
    int64 created_at_ms = 5;
    optional int64 completed_at_ms = 6;
}

message GetClusterStatusRequest {}

message GetClusterStatusResponse {
    // Current Raft term
    uint64 current_term = 1;
    // Leader node ID (always set since this response comes from the leader)
    uint64 leader_id = 2;
    // All nodes in the cluster with their health status
    repeated NodeInfo nodes = 3;
}

message NodeInfo {
    uint64 node_id = 1;
    string address = 2;
    bool is_alive = 3;
}

message GetRaftLogEntriesRequest {
    // Starting index (1-indexed, 0 means from beginning)
    uint64 start_index = 1;
    // Maximum number of entries to return (default: 100, max: 1000)
    uint32 limit = 2;
}

message GetRaftLogEntriesResponse {
    // Log entries in index order
    repeated RaftLogEntryInfo entries = 1;
    // Current commit index
    uint64 commit_index = 2;
    // Last log index (total entries in log)
    uint64 last_log_index = 3;
    // First available index (entries before this were compacted)
    uint64 first_available_index = 4;
}

message RaftLogEntryInfo {
    uint64 index = 1;
    uint64 term = 2;
    Command command = 3;
    bool is_committed = 4;
}

message TransferLeadershipRequest {
    // Target node ID to transfer leadership to (0 = auto-select best candidate)
    uint64 target_node_id = 1;
}

message TransferLeadershipResponse {
    bool success = 1;
    string message = 2;
    uint64 new_leader_id = 3;
}

message DrainNodeRequest {}

message DrainNodeResponse {
    bool success = 1;
    string message = 2;
}

// ==================== Internal Node-to-Node API ====================

service InternalService {
    // Fetch job output from the node that executed it
    rpc GetJobOutput(GetJobOutputRequest) returns (GetJobOutputResponse);
    // Worker heartbeat â€” keeps the leader's assigner aware of live workers
    rpc WorkerHeartbeat(WorkerHeartbeatRequest) returns (WorkerHeartbeatResponse);
    // Forward completed job status from a follower worker to the leader for Raft replication
    rpc ForwardJobStatus(ForwardJobStatusRequest) returns (ForwardJobStatusResponse);
}

message GetJobOutputRequest {
    string job_id = 1;
}

message GetJobOutputResponse {
    string job_id = 1;
    string output = 2;
    string error = 3;
    bool found = 4;
}

message WorkerHeartbeatRequest  { uint64 node_id = 1; }
message WorkerHeartbeatResponse {}

message ForwardJobStatusRequest  { repeated UpdateJobStatusCommand updates = 1; }
message ForwardJobStatusResponse {}

enum JobStatus {
    JOB_STATUS_UNSPECIFIED = 0;
    JOB_STATUS_PENDING = 1;
    JOB_STATUS_RUNNING = 2;
    JOB_STATUS_COMPLETED = 3;
    JOB_STATUS_FAILED = 4;
}
